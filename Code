#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <LittleFS.h>
#include <WiFiManager.h>
#include <ArduinoJson.h>
#include <map>

// === Struttura della lista collegata ===
struct Node {
  String data;
  Node* next;
};

struct StockData {
  float currentPrice = 0;
  float percent = 0;
};

std::map<String, StockData> stockCache;

Node* head = nullptr;

// === Stato per fetch non bloccante ===
Node* currentNode = nullptr;
unsigned long lastQuoteRequestTime = 0;
const unsigned long quoteDelay = 1500;
bool isFetching = false;

// === Altre variabili globali ===
const int wifiResetButtonPin = 12;  // D6
const int buttonPin = 14;
const int ledGreenPin = 13;  // GPIO13
const int ledRedPin = 15;    // GPIO15
bool serverMode = false;
int stockNum = 0;

Node* displayNode = nullptr;
unsigned long lastDisplaySwitch = 0;
const unsigned long displayInterval = 60000; // 1 minuto
bool newStock = false;

ESP8266WebServer server(80);

// === Funzioni Lista Collegata ===
void addNode(String value) {
  if (value == "") return;
  Node* newNode = new Node{value, nullptr};
  if (!head) head = newNode;
  else {
    Node* temp = head;
    while (temp->next) temp = temp->next;
    temp->next = newNode;
  }
  saveListToFS();
  stockNum++;
  newStock = true;
}

bool removeNode(String value) {
  Node* temp = head;
  Node* prev = nullptr;
  while (temp) {
    if (temp->data == value) {
      if (prev) prev->next = temp->next;
      else head = temp->next;
      delete temp;
      saveListToFS();
      stockNum--;
      return true;
    }
    prev = temp;
    temp = temp->next;
  }
  return false;
}

void clearList() {
  while (head) {
    Node* temp = head;
    head = head->next;
    delete temp;
  }
  saveListToFS();
  stockNum=0;

  // üîÅ Ferma qualsiasi fetch in corso
  currentNode = nullptr;
  isFetching = false;
}

String listToStringHTML() {
  String output = "<ul>";
  Node* temp = head;
  while (temp) {
    output += "<li>" + temp->data + "</li>";
    temp = temp->next;
  }
  output += "</ul>";
  return output;
}

// === Funzioni LittleFS ===
void saveListToFS() {
  File file = LittleFS.open("/list.txt", "w");
  if (!file) {
    Serial.println("Errore apertura file per scrittura!");
    return;
  }
  Node* temp = head;
  while (temp) {
    file.println(temp->data);
    temp = temp->next;
  }
  file.close();
}

void loadListFromFS() {
  if (!LittleFS.exists("/list.txt")) {
    Serial.println("‚ö†Ô∏è list.txt non trovato");
    return;
  }

  File file = LittleFS.open("/list.txt", "r");
  if (!file) {
    Serial.println("‚ö†Ô∏è Impossibile aprire list.txt in lettura");
    return;
  }

  Node* tempHead = nullptr;
  Node* tail = nullptr;  // Ottimizzazione
  int count = 0;         // Conta i nodi caricati

  while (file.available()) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() > 0) {
      Node* newNode = new Node{line, nullptr};
      if (!tempHead) {
        tempHead = newNode;
        tail = newNode;
      } else {
        tail->next = newNode;
        tail = newNode;
      }
      count++;
    }
  }
  file.close();

  if (tempHead) {
    clearList();
    head = tempHead;
    stockNum = count;  // ‚úÖ aggiorna correttamente
    Serial.println("‚úÖ Lista caricata da LittleFS");
  } else {
    Serial.println("‚ö†Ô∏è File vuoto o nessun dato valido");
  }
}


// === Web Server ===
void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <title>My Stocks</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .container {
      background-color: #fff;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    h1 {
      color: #333;
      font-size: 28px;
    }
    .form-row {
      margin: 10px 0;
    }
    form {
      display: flex;
    }
    .text-input {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px 0 0 4px;
      flex: 1;
    }
    .blue-button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
    }
    .blue-button:hover {
      background-color: #0b7dda;
    }
    .red-button {
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
    }
    .red-button:hover {
      background-color: #d32f2f;
    }
    ul {
      text-align: left;
      margin-top: 20px;
      padding-left: 20px;
    }
    li {
      background: #eee;
      margin: 4px 0;
      padding: 6px;
      border-radius: 4px;
    }
    #confirmModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      text-align: center;
    }
    .modal-content {
      background: white;
      margin: 15% auto;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
    }
  </style>
  <script>
    function showCustomConfirm() {
      document.getElementById("confirmModal").style.display = "block";
    }

    function hideCustomConfirm() {
      document.getElementById("confirmModal").style.display = "none";
    }

    function proceedClear() {
      window.location.href = "/clear";
    }
  </script>
</head>
<body>
  <div class="container">
    <h1>My Stocks</h1>

    <div class="form-row">
      <form action='/add'>
        <input type='text' name='value' placeholder='Add new stock' class='text-input'>
        <button type='submit' class='blue-button'>Add</button>
      </form>
    </div>

    <div class="form-row">
      <form action='/remove'>
        <input type='text' name='value' placeholder='Remove stock' class='text-input'>
        <button type='submit' class='blue-button'>Remove</button>
      </form>
    </div>

    <button class='red-button' onclick='showCustomConfirm()'>Erase all</button>

    <h3>My stocks:</h3>
)rawliteral";

  html += listToStringHTML();

  html += R"rawliteral(
  </div>

  <!-- Custom Confirm Modal -->
  <div id="confirmModal">
    <div class="modal-content">
      <h3>Are you sure?</h3>
      <p>This will delete the entire list.</p>
      <button onclick="proceedClear()" class="red-button">Yes, erase</button>
      <button onclick="hideCustomConfirm()">Cancel</button>
    </div>
  </div>

</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}



void handleAdd() {
  String value = server.arg("value");
  if (value.length() > 0) {
    addNode(value);
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  } else {
    server.send(400, "text/plain", "Missing 'value'");
  }
}

void handleRemove() {
  String value = server.arg("value");
  if (value.length() > 0) {
    bool removed = removeNode(value);
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", removed ? "Removed" : "Not found");
  } else {
    server.send(400, "text/plain", "Missing 'value'");
  }
}

void handleClear() {
  clearList();
  server.sendHeader("Location", "/", true);
  server.send(302, "text/plain", "");
}

void handleNonBlockingFetch() {
  if (!isFetching) return;
  if (!currentNode) {
    Serial.println("‚úÖ Completato ciclo fetch.");
    isFetching = false;
    return;
  }

  if (millis() - lastQuoteRequestTime < quoteDelay) return;

  String symbol = currentNode->data;
  symbol.replace("/", "");
  String apiKey = "d1vq1a9r01qmbi8phj8gd1vq1a9r01qmbi8phj90";
  String url = "https://finnhub.io/api/v1/quote?symbol=" + symbol + "&token=" + apiKey;

  WiFiClientSecure client;
  client.setInsecure();

  HTTPClient https;
  Serial.println("üîé Requesting: " + url);

  if (https.begin(client, url)) {
    https.addHeader("User-Agent", "Mozilla/5.0");
    int httpCode = https.GET();

    if (httpCode == HTTP_CODE_OK) {
      String payload = https.getString();
      DynamicJsonDocument doc(1024);
      if (deserializeJson(doc, payload)) {
        Serial.println("‚ö†Ô∏è JSON parsing error");
      } else {
        float currentPrice = doc["c"];
        float prevClose = doc["pc"];
        float percent = 0;
        if (prevClose != 0) {
          percent = ((currentPrice - prevClose) / prevClose) * 100.0;
        }

        stockCache[symbol] = { currentPrice, percent };
        Serial.printf("üì• %s: %.2f (%.2f%%)\n", symbol.c_str(), currentPrice, percent);

      }
    } else {
      Serial.printf("‚ö†Ô∏è HTTP error: %d\n", httpCode);
    }
    https.end();
  } else {
    Serial.println("[HTTPS] Connection failed");
  }

  lastQuoteRequestTime = millis();
  currentNode = currentNode->next;
}


// === Gestione pulsante migliorata ===
void checkButton() {
  static bool buttonPreviouslyPressed = false;

  bool currentReading = digitalRead(buttonPin); // HIGH quando premuto con pull-down

  if (currentReading && !buttonPreviouslyPressed) {
    // Bottone √® appena stato premuto
    serverMode = !serverMode;
    isFetching = false;  // Ferma eventuale fetch in corso
    Serial.print("üîÅ Modalit√† cambiata: ");
    Serial.println(serverMode ? "SERVER" : "DISPLAY");

     // Spegni entrambi i LED al cambio modalit√†
    digitalWrite(ledGreenPin, LOW);
    digitalWrite(ledRedPin, LOW);
  }

  buttonPreviouslyPressed = currentReading;
}


void updateDisplay() {
  if (!displayNode) displayNode = head;
  if (!displayNode) return;  // lista vuota

  if (millis() - lastDisplaySwitch >= displayInterval) {
    displayNode = displayNode->next;
    if (!displayNode) displayNode = head; // ricomincia da capo
    lastDisplaySwitch = millis();

    String symbol = displayNode->data;
    symbol.replace("/", "");

    if (stockCache.count(symbol)) {
      StockData data = stockCache[symbol];
      Serial.printf("üì∫ Mostrando %s: %.2f (%.2f%%)\n", symbol.c_str(), data.currentPrice, data.percent);

      // === Controllo LED ===
      if (data.percent > 0) {
        digitalWrite(ledGreenPin, HIGH);
        digitalWrite(ledRedPin, LOW);
      } else {
        digitalWrite(ledGreenPin, LOW);
        digitalWrite(ledRedPin, HIGH);
      }

    } else {
      Serial.printf("üì∫ %s: dati non disponibili\n", symbol.c_str());
      digitalWrite(ledGreenPin, LOW);
      digitalWrite(ledRedPin, LOW);  // spegne entrambi se non c'√® dato
    }
  }
}

void blinkLedsInServerMode() {
  static unsigned long lastBlinkTime = 0;
  static bool ledState = false;

  const unsigned long blinkInterval = 800;  // ms

  if (millis() - lastBlinkTime >= blinkInterval) {
    ledState = !ledState;
    digitalWrite(ledGreenPin, ledState ? HIGH : LOW);
    digitalWrite(ledRedPin, ledState ? LOW : HIGH);
    lastBlinkTime = millis();
  }
}



// === Setup ===
void setup() {
  Serial.begin(115200);

  if (!LittleFS.begin()) {
    Serial.println("LittleFS mount failed");
    return;
  }

  WiFiManager wifiManager;
  if (!wifiManager.autoConnect("WallStreetDisplay", "12345678")) {
    Serial.println("Wi-Fi fallita. Riavvio...");
    delay(3000);
    ESP.restart();
  }

  Serial.print("Connesso. IP: ");
  Serial.println(WiFi.localIP());

  loadListFromFS();

  server.on("/", handleRoot);
  server.on("/add", handleAdd);
  server.on("/remove", handleRemove);
  server.on("/clear", handleClear);
  server.begin();

  pinMode(buttonPin, INPUT);  //non INPUT_PULLUP
  pinMode(wifiResetButtonPin, INPUT);
  pinMode(ledGreenPin, OUTPUT);
  pinMode(ledRedPin, OUTPUT);
  digitalWrite(ledGreenPin, LOW);
  digitalWrite(ledRedPin, LOW);

  Serial.println("üü¢ Avviato in modalit√† DISPLAY");
  newStock = true; //when turned on downloads new data
}

// === Loop ===
unsigned long lastRequest = 0;


void loop() {
  checkButton();

  if (serverMode) {
    server.handleClient();
    blinkLedsInServerMode();  // üîÅ lampeggia in modalit√† server
  } else {

    if (!head) {
      Serial.println("‚ö†Ô∏è Nessuno stock da mostrare. Passa in modalit√† SERVER per aggiungere i tuoi stock.");
      delay(3000);  // evita flooding della seriale
      return;
    }

    // Ogni 10 minuti fai fetch se non in corso
    if ((!isFetching && millis() - lastRequest > 600000)||(newStock)) {
      currentNode = head;
      isFetching = true;
      lastQuoteRequestTime = millis() - quoteDelay;
      lastRequest = millis();
    }

    if (isFetching) {
      handleNonBlockingFetch();
      if(newStock){
       newStock = false;
      }
    } else {
      updateDisplay();  // mostra lo stock corrente ogni 1 minuto
    }
  }

  static bool wifiResetPressed = false;
  static unsigned long wifiResetStart = 0;

if (digitalRead(wifiResetButtonPin) == HIGH) {  // button pressed
  if (!wifiResetPressed) {
    wifiResetPressed = true;
    wifiResetStart = millis();
  } else if (millis() - wifiResetStart > 5000) {  // held > 5 sec
    Serial.println("üîß WiFi reset requested via dedicated button");
    digitalWrite(ledGreenPin, LOW);
    digitalWrite(ledRedPin, LOW);
    delay(500);
    WiFiManager wifiManager;
    wifiManager.resetSettings();
    delay(500);
    ESP.restart();
  }
} else {
  wifiResetPressed = false;  // reset if button released early
}

}
