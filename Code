#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <LittleFS.h>
#include <WiFiManager.h>
#include <ArduinoJson.h>
#include <map>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Fonts/FreeSansBold9pt7b.h>
#include <Fonts/FreeSansBold12pt7b.h>

// I2C pins for ESP8266 (D1 = SCL, D2 = SDA)
#define SCREEN_WIDTH 128 // OLED width, in pixels
#define SCREEN_HEIGHT 64 // OLED height, in pixels
#define OLED_RESET -1 // No reset pin
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
uint8_t virtualBuffer[2048]; // 256 x 64 bits

// === Struttura della linked list ===
struct Node {
  String data;
  Node* next;
};

struct StockData {
  float currentPrice = 0;
  float percent = 0;
};

struct tm timeinfo;

// Possible display states
enum DisplayState {
    SHOW_STOCK,
    TRANSITION_TO_COUNTDOWN,
    SHOW_COUNTDOWN,
    TRANSITION_TO_STOCK
};

static DisplayState displayState = SHOW_STOCK;
static unsigned long stateStartTime = 0;
static String oldSymbol = "";
static StockData oldData;
static bool firstRun = true;

std::map<String, StockData> stockCache;

Node* head = nullptr;

// === Stato per fetch non bloccante ===
Node* currentNode = nullptr;
unsigned long lastQuoteRequestTime = 0;
const unsigned long quoteDelay = 1500;
bool isFetching = false;

// === Altre variabili globali ===
const int wifiResetButtonPin = 12;  // D6
const int buttonPin = 14;
const int ledGreenPin = 13;  // GPIO13
const int ledRedPin = 15;    // GPIO15
bool serverMode = false;
int stockNum = 0;

Node* displayNode = nullptr;
unsigned long lastDisplaySwitch = 0;
const unsigned long displayInterval = 5000; // 5 sec
bool newStock = false;

// Example market hours (NY Stock Exchange)
const int MARKET_OPEN_HOUR = 15;
const int MARKET_OPEN_MINUTE = 30;
const int MARKET_CLOSE_HOUR = 22;
const int MARKET_CLOSE_MINUTE = 0;

// Previous countdown text (for sliding animation)
String prevStatus = "";
String prevCountdown = "";


// NTP servers
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 3600;   // CET is UTC+1
const int   daylightOffset_sec = 3600; // +1 hour for CEST (DST)


// Example 24x24 server icon bitmap
const unsigned char PROGMEM serverIcon[] = {
  0x00,0x00,0x00, 0x1F,0xFF,0x80, 0x20,0x00,0x40,
  0x27,0xFF,0x40, 0x24,0x00,0x40, 0x24,0xFF,0x40,
  0x24,0x81,0x40, 0x24,0xFF,0x40, 0x24,0x00,0x40,
  0x27,0xFF,0x40, 0x20,0x00,0x40, 0x1F,0xFF,0x80,
  0x00,0x00,0x00, 0x1F,0xFF,0x80, 0x20,0x00,0x40,
  0x27,0xFF,0x40, 0x24,0x00,0x40, 0x24,0xFF,0x40,
  0x24,0x81,0x40, 0x24,0xFF,0x40, 0x24,0x00,0x40,
  0x27,0xFF,0x40, 0x20,0x00,0x40, 0x1F,0xFF,0x80
};

// New 24x24 stock market arrow up icon bitmap (monochrome)
const unsigned char PROGMEM dollarIcon[] = {
  0x00,0x20,0x00,
  0x00,0x70,0x00,
  0x01,0xF8,0x00,
  0x03,0xFC,0x00,
  0x07,0xEE,0x00,
  0x07,0x8E,0x00,
  0x07,0x80,0x00,
  0x03,0xF8,0x00,
  0x01,0xFE,0x00,
  0x00,0x7F,0x00,
  0x00,0x0F,0x00,
  0x07,0x0F,0x00,
  0x07,0x8F,0x00,
  0x07,0xFE,0x00,
  0x03,0xFC,0x00,
  0x01,0xF8,0x00,
  0x00,0x70,0x00,
  0x00,0x20,0x00,
  0x00,0x00,0x00,
  0x00,0x00,0x00,
  0x00,0x00,0x00,
  0x00,0x00,0x00,
  0x00,0x00,0x00,
  0x00,0x00,0x00
};

const unsigned char PROGMEM wifiDraw[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 
	0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 
	0x00, 0x7f, 0xff, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x00, 0x1f, 0xff, 0x00, 
	0x01, 0xff, 0xe0, 0x00, 0x00, 0x07, 0xff, 0x80, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 
	0x07, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x07, 0xf8, 0x00, 0xff, 0xff, 0x00, 0x1f, 0xe0, 
	0x07, 0xf0, 0x07, 0xff, 0xff, 0xe0, 0x0f, 0xe0, 0x07, 0xe0, 0x3f, 0xff, 0xff, 0xfc, 0x07, 0xe0, 
	0x03, 0xc0, 0x7f, 0xff, 0xff, 0xfe, 0x03, 0xc0, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 
	0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x07, 0xff, 0xf0, 0x00, 
	0x00, 0x0f, 0xfe, 0x00, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x1f, 0xf8, 0x00, 
	0x00, 0x1f, 0xe0, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0x03, 0xf8, 0x00, 
	0x00, 0x0f, 0x00, 0x0f, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x03, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0x80, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x60, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

ESP8266WebServer server(80);

void drawStockFrame(String symbol, StockData data, int xOffset);
void updateLEDs(StockData data);


// === Funzioni Lista Collegata ===
void addNode(String value) {
  if (value == "") return;
  Node* newNode = new Node{value, nullptr};
  if (!head) head = newNode;
  else {
    Node* temp = head;
    while (temp->next) temp = temp->next;
    temp->next = newNode;
  }
  saveListToFS();
  stockNum++;
  newStock = true;
}

bool removeNode(String value) {
  Node* temp = head;
  Node* prev = nullptr;
  while (temp) {
    if (temp->data == value) {
      if (prev) prev->next = temp->next;
      else head = temp->next;
      delete temp;
      saveListToFS();
      stockNum--;
      return true;
    }
    prev = temp;
    temp = temp->next;
  }
  return false;
}

void clearList() {
  while (head) {
    Node* temp = head;
    head = head->next;
    delete temp;
  }
  saveListToFS();
  stockNum=0;

  // üîÅ Ferma qualsiasi fetch in corso
  currentNode = nullptr;
  isFetching = false;
}

String listToStringHTML() {
  String output = "<ul>";
  Node* temp = head;
  while (temp) {
    output += "<li>" + temp->data + "</li>";
    temp = temp->next;
  }
  output += "</ul>";
  return output;
}

// === Funzioni LittleFS ===
void saveListToFS() {
  File file = LittleFS.open("/list.txt", "w");
  if (!file) {
    Serial.println("Errore apertura file per scrittura!");
    return;
  }
  Node* temp = head;
  while (temp) {
    file.println(temp->data);
    temp = temp->next;
  }
  file.close();
}

void loadListFromFS() {
  if (!LittleFS.exists("/list.txt")) {
    Serial.println("‚ö†Ô∏è list.txt non trovato");
    return;
  }

  File file = LittleFS.open("/list.txt", "r");
  if (!file) {
    Serial.println("‚ö†Ô∏è Impossibile aprire list.txt in lettura");
    return;
  }

  Node* tempHead = nullptr;
  Node* tail = nullptr;  // Ottimizzazione
  int count = 0;         // Conta i nodi caricati

  while (file.available()) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() > 0) {
      Node* newNode = new Node{line, nullptr};
      if (!tempHead) {
        tempHead = newNode;
        tail = newNode;
      } else {
        tail->next = newNode;
        tail = newNode;
      }
      count++;
    }
  }
  file.close();

  if (tempHead) {
    clearList();
    head = tempHead;
    stockNum = count;  // ‚úÖ aggiorna correttamente
    Serial.println("‚úÖ Lista caricata da LittleFS");
  } else {
    Serial.println("‚ö†Ô∏è File vuoto o nessun dato valido");
  }
}

// === Web Server ===
void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <title>My Stocks</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f2f2f2;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .container {
      background-color: #fff;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    h1 {
      color: #333;
      font-size: 28px;
    }
    .form-row {
      margin: 10px 0;
    }
    form {
      display: flex;
    }
    .text-input {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px 0 0 4px;
      flex: 1;
    }
    .blue-button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
    }
    .blue-button:hover {
      background-color: #0b7dda;
    }
    .red-button {
      padding: 10px 20px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 15px;
    }
    .red-button:hover {
      background-color: #d32f2f;
    }
    ul {
      text-align: left;
      margin-top: 20px;
      padding-left: 20px;
    }
    li {
      background: #eee;
      margin: 4px 0;
      padding: 6px;
      border-radius: 4px;
    }
    #confirmModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      text-align: center;
    }
    .modal-content {
      background: white;
      margin: 15% auto;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
    }
  </style>
  <script>
    function showCustomConfirm() {
      document.getElementById("confirmModal").style.display = "block";
    }

    function hideCustomConfirm() {
      document.getElementById("confirmModal").style.display = "none";
    }

    function proceedClear() {
      window.location.href = "/clear";
    }
  </script>
</head>
<body>
  <div class="container">
    <h1>My Stocks</h1>

    <div class="form-row">
      <form action='/add'>
        <input type='text' name='value' placeholder='Add new stock' class='text-input'>
        <button type='submit' class='blue-button'>Add</button>
      </form>
    </div>

    <div class="form-row">
      <form action='/remove'>
        <input type='text' name='value' placeholder='Remove stock' class='text-input'>
        <button type='submit' class='blue-button'>Remove</button>
      </form>
    </div>

    <button class='red-button' onclick='showCustomConfirm()'>Erase all</button>

    <h3>My stocks:</h3>
)rawliteral";

  html += listToStringHTML();

  html += R"rawliteral(
  </div>

  <!-- Custom Confirm Modal -->
  <div id="confirmModal">
    <div class="modal-content">
      <h3>Are you sure?</h3>
      <p>This will delete the entire list.</p>
      <button onclick="proceedClear()" class="red-button">Yes, erase</button>
      <button onclick="hideCustomConfirm()">Cancel</button>
    </div>
  </div>

</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}



void handleAdd() {
  String value = server.arg("value");
  if (value.length() > 0) {
    addNode(value);
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", "");
  } else {
    server.send(400, "text/plain", "Missing 'value'");
  }
}

void handleRemove() {
  String value = server.arg("value");
  if (value.length() > 0) {
    bool removed = removeNode(value);
    server.sendHeader("Location", "/", true);
    server.send(302, "text/plain", removed ? "Removed" : "Not found");
  } else {
    server.send(400, "text/plain", "Missing 'value'");
  }
}

void handleClear() {
  clearList();
  server.sendHeader("Location", "/", true);
  server.send(302, "text/plain", "");
}

void handleNonBlockingFetch() {
  if (!isFetching) return;
  if (!currentNode) {
    Serial.println("‚úÖ Completato ciclo fetch.");
    isFetching = false;
    return;
  }

  if (millis() - lastQuoteRequestTime < quoteDelay) return;

  String symbol = currentNode->data;
  symbol.replace("/", "");
  String apiKey = "d1vq1a9r01qmbi8phj8gd1vq1a9r01qmbi8phj90";
  String url = "https://finnhub.io/api/v1/quote?symbol=" + symbol + "&token=" + apiKey;

  WiFiClientSecure client;
  client.setInsecure();

  HTTPClient https;
  Serial.println("üîé Requesting: " + url);

  if (https.begin(client, url)) {
    https.addHeader("User-Agent", "Mozilla/5.0");
    int httpCode = https.GET();

    if (httpCode == HTTP_CODE_OK) {
      String payload = https.getString();
      DynamicJsonDocument doc(1024);
      if (deserializeJson(doc, payload)) {
        Serial.println("‚ö†Ô∏è JSON parsing error");
      } else {
        float currentPrice = doc["c"];
        float prevClose = doc["pc"];
        float percent = 0;
        if (prevClose != 0) {
          percent = ((currentPrice - prevClose) / prevClose) * 100.0;
        }

        stockCache[symbol] = { currentPrice, percent };
        Serial.printf("üì• %s: %.2f (%.2f%%)\n", symbol.c_str(), currentPrice, percent);

      }
    } else {
      Serial.printf("‚ö†Ô∏è HTTP error: %d\n", httpCode);
    }
    https.end();
  } else {
    Serial.println("[HTTPS] Connection failed");
  }

  lastQuoteRequestTime = millis();
  currentNode = currentNode->next;
}

void fetchSingleStock(String symbol) {
    symbol.replace("/", "");
    String apiKey = "d1vq1a9r01qmbi8phj8gd1vq1a9r01qmbi8phj90";
    String url = "https://finnhub.io/api/v1/quote?symbol=" + symbol + "&token=" + apiKey;

    WiFiClientSecure client;
    client.setInsecure();

    HTTPClient https;
    Serial.println("üîé Requesting: " + url);

    if (https.begin(client, url)) {
        https.addHeader("User-Agent", "Mozilla/5.0");
        int httpCode = https.GET();

        if (httpCode == HTTP_CODE_OK) {
            String payload = https.getString();
            DynamicJsonDocument doc(1024);
            if (deserializeJson(doc, payload)) {
                Serial.println("‚ö†Ô∏è JSON parsing error");
            } else {
                float currentPrice = doc["c"];
                float prevClose = doc["pc"];
                float percent = 0;
                if (prevClose != 0) {
                    percent = ((currentPrice - prevClose) / prevClose) * 100.0;
                }

                stockCache[symbol] = { currentPrice, percent };
                Serial.printf("üì• %s: %.2f (%.2f%%)\n", symbol.c_str(), currentPrice, percent);
            }
        } else {
            Serial.printf("‚ö†Ô∏è HTTP error: %d\n", httpCode);
        }
        https.end();
    } else {
        Serial.println("[HTTPS] Connection failed");
    }
}

StockData fetchSingleStockWithRetry(String symbol) {
    StockData data = stockCache[symbol]; // start with cached data

    for (int retry = 0; retry < 2; retry++) { // exactly 2 attempts max
        if (data.currentPrice != 0) break;    // success, stop retrying
        fetchSingleStock(symbol);             // updates stockCache (no drawing)
        data = stockCache[symbol];            // refresh data
        delay(150);                           // small wait between tries
    }

    return data; // even if still zero, return so display can skip to next
}

// === Gestione pulsante migliorata ===
void checkButton() {
  static bool buttonPreviouslyPressed = false;

  bool currentReading = digitalRead(buttonPin); // HIGH quando premuto con pull-down

  if (currentReading && !buttonPreviouslyPressed) {
    // Bottone √® appena stato premuto
    serverMode = !serverMode;
    isFetching = false;  // Ferma eventuale fetch in corso
    Serial.print("üîÅ Modalit√† cambiata: ");
    Serial.println(serverMode ? "SERVER" : "DISPLAY");

     // Spegni entrambi i LED al cambio modalit√†
    digitalWrite(ledGreenPin, LOW);
    digitalWrite(ledRedPin, LOW);
  }

  buttonPreviouslyPressed = currentReading;
}

bool marketIsOpen() {
    int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
    int openMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE;
    int closeMinutes = MARKET_CLOSE_HOUR * 60 + MARKET_CLOSE_MINUTE;

    return currentMinutes >= openMinutes && currentMinutes < closeMinutes;
}

String getMarketCountdown() {
    // Market hours in Italy (example: winter time)
    const int MARKET_OPEN_HOUR = 15;
    const int MARKET_OPEN_MINUTE = 30;
    const int MARKET_CLOSE_HOUR = 22;
    const int MARKET_CLOSE_MINUTE = 0;

    int currentMinutes = timeinfo.tm_hour * 60 + timeinfo.tm_min;
    int openMinutes    = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE;
    int closeMinutes   = MARKET_CLOSE_HOUR * 60 + MARKET_CLOSE_MINUTE;

    int targetMinutes;

    if (currentMinutes < openMinutes) {
        // before open ‚Üí countdown to open
        targetMinutes = openMinutes;
    } else if (currentMinutes < closeMinutes) {
        // after open, before close ‚Üí countdown to close
        targetMinutes = closeMinutes;
    } else {
        // after close ‚Üí countdown to tomorrow‚Äôs open
        targetMinutes = openMinutes + 24 * 60;
    }

    int diff = targetMinutes - currentMinutes;
    int hoursLeft = diff / 60;
    int minutesLeft = diff % 60;

    return String(hoursLeft) + "h " + String(minutesLeft) + "m";
}

// Blit 128x64 window at horizontal offset into SSD1306 buffer
void blitWindowToDisplay(int xOffset) {
  uint8_t* dispBuf = display.getBuffer();
  memset(dispBuf, 0, 1024);

  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 128; x++) {
      int srcX = x + xOffset;
      if (srcX < 0 || srcX >= 256) continue; // virtual buffer is 256 wide

      // --- read from virtual buffer (linear 256x64 1bpp) ---
      int srcIndex = y * 256 + srcX;
      int srcByte = srcIndex / 8;
      int srcBit = 7 - (srcIndex % 8);
      bool pixel = (virtualBuffer[srcByte] >> srcBit) & 0x01;

      if (pixel) {
        // --- write into Adafruit buffer (paged 128x64) ---
        int dstIndex = x + (y / 8) * 128;
        dispBuf[dstIndex] |= (1 << (y & 7));
      }
    }
  }
}

// Helper: clear virtual buffer
void clearVirtualBuffer() {
  memset(virtualBuffer, 0, sizeof(virtualBuffer));
}

// Wrapper: draw into virtual buffer at xOffset
void drawStockFrameToVirtual(String symbol, StockData data, int xOffset) {
  display.clearDisplay();
  drawStockFrame(symbol, data, 0);   // draw into SSD1306 buffer
  uint8_t* src = display.getBuffer();

  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 128; x++) {
      int dstX = x + xOffset;
      if (dstX >= 128*2) continue; // virtual buffer is 256px wide

      // --- read from Adafruit buffer ---
      int srcIndex = x + (y / 8) * 128;
      bool pixel = (src[srcIndex] >> (y & 7)) & 0x1;

      if (pixel) {
        // --- write into virtual buffer (linear 1bpp) ---
        int dstIndex = y * 256 + dstX;  // now width is 256
        int dstByte = dstIndex / 8;
        int dstBit = 7 - (dstIndex % 8);   // MSB first
        virtualBuffer[dstByte] |= (1 << dstBit);
      }
    }
  }
}

// Horizontal slide animation using virtual 256x64 framebuffer
void slideFramesHorizontal(
    const String& oldSymbol, const StockData& oldData,
    const String& newSymbol, const StockData& newData,
    int step = 4, int delayTime = 20) 
{
  clearVirtualBuffer();

  // Draw old frame in left half
  drawStockFrameToVirtual(oldSymbol, oldData, 0);

  // Draw new frame in right half
  drawStockFrameToVirtual(newSymbol, newData, 128);

  // Animate scrolling from x=0..128
  for (int offset = 0; offset <= 128; offset += step) {
    blitWindowToDisplay(offset);
    display.display();
    delay(delayTime);
  }
}

void drawCountdownFrame(const String& statusText, const String& countdown) {
  display.clearDisplay();
  
  // First line: OPENS / CLOSES
  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  
  int16_t x1, y1;
  uint16_t w, h;
  display.getTextBounds(statusText, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 20);
  display.print(statusText);

  // Second line: countdown
  display.getTextBounds(countdown, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 45);
  display.print(countdown);
}

void slideStockToCountdown(
    const String& symbol, const StockData& data,
    const String& statusText, const String& countdown,
    int step = 4, int delayTime = 20) 
{
  clearVirtualBuffer();

  // Stock a sinistra
  drawStockFrameToVirtual(symbol, data, 0);

  // Countdown a destra
  drawCountdownFrameVirtual(statusText, countdown, 128);

  // Scroll
  for (int offset = 0; offset <= 128; offset += step) {
    blitWindowToDisplay(offset);
    display.display();
    delay(delayTime);
  }
}

void slideCountdownToStock(
    const String& statusText, const String& countdown,
    const String& symbol, const StockData& data,
    int step = 4, int delayTime = 20) 
{
  clearVirtualBuffer();

  // Countdown a sinistra
  drawCountdownFrameVirtual(statusText, countdown, 0);

  // Stock a destra
  drawStockFrameToVirtual(symbol, data, 128);

  // Scroll
  for (int offset = 0; offset <= 128; offset += step) {
    blitWindowToDisplay(offset);
    display.display();
    delay(delayTime);
  }
}

void drawCountdownFrameVirtual(const String& statusText, const String& countdown, int xOffset) {
  display.clearDisplay();

  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  int16_t x1, y1;
  uint16_t w, h;

  // Prima riga
  display.getTextBounds(statusText, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 20);
  display.print(statusText);

  // Seconda riga
  display.getTextBounds(countdown, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 45);
  display.print(countdown);

  // Copia nel virtual buffer
  uint8_t* src = display.getBuffer();
  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 128; x++) {
      int dstX = x + xOffset;
      if (dstX >= 256) continue;

      int srcIndex = x + (y / 8) * 128;
      bool pixel = (src[srcIndex] >> (y & 7)) & 0x1;

      if (pixel) {
        int dstIndex = y * 256 + dstX;
        int dstByte = dstIndex / 8;
        int dstBit = 7 - (dstIndex % 8);
        virtualBuffer[dstByte] |= (1 << dstBit);
      }
    }
  }
}

void drawCountdownToVirtual(const String& statusText, const String& countdown, int xOffset) {
  display.clearDisplay();

  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  int16_t x1, y1;
  uint16_t w, h;

  // Prima riga: OPENS / CLOSES
  display.getTextBounds(statusText, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 20);
  display.print(statusText);

  // Seconda riga: countdown
  display.getTextBounds(countdown, 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 45);
  display.print(countdown);

  // Copia nel virtual buffer
  uint8_t* src = display.getBuffer();
  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 128; x++) {
      int dstX = x + xOffset;
      if (dstX >= 256) continue;

      int srcIndex = x + (y / 8) * 128;
      bool pixel = (src[srcIndex] >> (y & 7)) & 0x1;

      if (pixel) {
        int dstIndex = y * 256 + dstX;
        int dstByte = dstIndex / 8;
        int dstBit = 7 - (dstIndex % 8);
        virtualBuffer[dstByte] |= (1 << dstBit);
      }
    }
  }
}

// ----------------- Helpers -----------------
String sanitizeSymbol(const String& raw) {
    String sym = raw;
    sym.replace("/", "");
    return sym;
}

StockData fetchStockData(const String& symbol) {
    StockData data;
    if (stockCache.count(symbol)) data = stockCache[symbol];
    if (data.currentPrice == 0) {
        data = fetchSingleStockWithRetry(symbol);
        stockCache[symbol] = data;
    }
    return data;
}

void blinkMarketLEDsNonBlocking() {
    static unsigned long lastBlink = 0;
    static bool state = false;

    if (millis() - lastBlink > 200) { // blink interval
        lastBlink = millis();
        state = !state;

        if (marketIsOpen()) {
            // Alternate green/red
            digitalWrite(ledGreenPin, state);
            digitalWrite(ledRedPin, !state);
        } else {
            // Only red blinks
            digitalWrite(ledGreenPin, LOW);
            digitalWrite(ledRedPin, state);
        }
    }
}

// ----------------- Main Display Function -----------------
void updateDisplay() {
    if (!displayNode) displayNode = head;
    if (!displayNode) return;

    String statusText = marketIsOpen() ? "CLOSES" : "OPENS";
    String countdown = getMarketCountdown();

    String newSymbol = sanitizeSymbol(displayNode->data);
    StockData newData = fetchStockData(newSymbol);

    switch (displayState) {
        case SHOW_STOCK: {
            if (firstRun) {
                // First stock at startup
                drawStockFrame(newSymbol, newData, 0);
                display.display();
                updateLEDs(newData);
                firstRun = false;
                stateStartTime = millis();
                oldSymbol = newSymbol;
                oldData = newData;
                return;
            }

            if (millis() - stateStartTime > displayInterval) {
                // Advance stock
                displayNode = displayNode->next;
                if (!displayNode) {
                    displayNode = head;
                    displayState = TRANSITION_TO_COUNTDOWN;
                } else {
                    // Slide to next stock
                    String nextSymbol = sanitizeSymbol(displayNode->data);
                    StockData nextData = fetchStockData(nextSymbol);

                    updateLEDs(nextData);
                    slideFramesHorizontal(oldSymbol, oldData, nextSymbol, nextData);

                    oldSymbol = nextSymbol;
                    oldData = nextData;
                    stateStartTime = millis();
                }
            }
            break;
        }

        case TRANSITION_TO_COUNTDOWN: {
            slideStockToCountdown(oldSymbol, oldData, statusText, countdown);
            displayState = SHOW_COUNTDOWN;
            stateStartTime = millis();
            break;
        }

        case SHOW_COUNTDOWN: {
            blinkMarketLEDsNonBlocking();

            if (millis() - stateStartTime > displayInterval) {
                displayState = TRANSITION_TO_STOCK;
            }
            break;
        }

        case TRANSITION_TO_STOCK: {
            // Move countdown ‚Üí first stock
            String nextSymbol = sanitizeSymbol(displayNode->data);
            StockData nextData = fetchStockData(nextSymbol);

            slideCountdownToStock(statusText, countdown, nextSymbol, nextData);
            updateLEDs(nextData);

            oldSymbol = nextSymbol;
            oldData = nextData;

            displayState = SHOW_STOCK;
            stateStartTime = millis();
            break;
        }
    }
}

// Call this ONCE per stock change, not inside the animation loop
void updateLEDs(StockData data) {
    if (data.percent > 0) {
        digitalWrite(ledGreenPin, HIGH);
        digitalWrite(ledRedPin, LOW);
    } else if (data.percent < 0) {
        digitalWrite(ledGreenPin, LOW);
        digitalWrite(ledRedPin, HIGH);
    } else {
        digitalWrite(ledGreenPin, LOW);
        digitalWrite(ledRedPin, LOW);
    }
}

void drawStockFrame(String symbol, StockData data, int xOffset) {
    int16_t x1, y1;
    uint16_t w, h;

    // Don‚Äôt draw if frame is completely off-screen
    if (xOffset <= -SCREEN_WIDTH || xOffset >= SCREEN_WIDTH) return;

    // --- SYMBOL ---
    display.setFont(&FreeSansBold9pt7b);
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    display.getTextBounds(symbol, 0, 0, &x1, &y1, &w, &h);
    int symbolX = (SCREEN_WIDTH - w) / 2 + xOffset;
    int symbolY = h + 4;
    display.setCursor(symbolX, symbolY);
    display.print(symbol);

    // --- PRICE ---
    display.setFont(&FreeSansBold12pt7b);
    String priceStr = "$ " + String(data.currentPrice, 2);
    display.getTextBounds(priceStr, 0, 0, &x1, &y1, &w, &h);
    int priceX = (SCREEN_WIDTH - w) / 2 + xOffset;
    int priceY = 40;  
    display.setCursor(priceX, priceY);
    display.print(priceStr);

    // --- PERCENT ---
    display.setFont(&FreeSansBold9pt7b);
    String changeStr = String(data.percent, 2) + " %";
    display.getTextBounds(changeStr, 0, 0, &x1, &y1, &w, &h);
    int changeX = (SCREEN_WIDTH - w) / 2 + xOffset;
    int changeY = 60;
    display.setCursor(changeX, changeY);
    display.print(changeStr);
}

void showServerMode() {
  display.clearDisplay();
  
  // Disegna icona server centrata in alto
  display.drawBitmap((SCREEN_WIDTH - 24) / 2, 4, serverIcon, 24, 24, SSD1306_WHITE);

  // Imposta font pi√π piccolo di prima
  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  // Calcola per centrare il testo
  int16_t x1, y1;
  uint16_t w, h;
  String text = "SERVER";
  display.getTextBounds(text, 0, 0, &x1, &y1, &w, &h);

  // Posiziona testo sotto l‚Äôicona
  display.setCursor((SCREEN_WIDTH - w) / 2, 48);
  display.print(text);

  display.display();
}

void showWallStreet() {
  display.clearDisplay();
  
  // Draw $ icon centered at top
  display.drawBitmap((SCREEN_WIDTH - 24) / 2, 0, dollarIcon, 24, 24, SSD1306_WHITE);

  // Bold font
  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  int16_t x1, y1;
  uint16_t w, h;

  // "WALL"
  display.getTextBounds("WALL", 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 40);
  display.print("WALL");

  // "STREET"
  display.getTextBounds("STREET", 0, 0, &x1, &y1, &w, &h);
  display.setCursor((SCREEN_WIDTH - w) / 2, 56);
  display.print("STREET");

  display.display();
}

void blinkLedsInServerMode() {
  static unsigned long lastBlinkTime = 0;
  static bool ledState = false;

  const unsigned long blinkInterval = 800;  // ms

  if (millis() - lastBlinkTime >= blinkInterval) {
    ledState = !ledState;
    digitalWrite(ledGreenPin, ledState ? HIGH : LOW);
    digitalWrite(ledRedPin, ledState ? LOW : HIGH);
    lastBlinkTime = millis();
  }
}

// === Setup ===
void setup() {
  Serial.begin(115200);

  if (!LittleFS.begin()) {
    Serial.println("LittleFS mount failed");
    return;
  }

  Wire.begin(D2, D1); // SDA, SCL
 
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for most OLEDs
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); // Don't proceed, loop forever
  }

  // --- Show WiFi icon at startup ---
  display.clearDisplay();
  display.drawBitmap(32, 0, wifiDraw, 64, 64, SSD1306_WHITE);
  display.display();

  // --- WiFi Manager ---
  WiFiManager wifiManager;
  if (!wifiManager.autoConnect("WallStreetDisplay", "12345678")) {
    Serial.println("Wi-Fi fallita. Riavvio...");
    delay(3000);
    ESP.restart();
  } 

  // --- At this point autoConnect returned successfully ---
  if (WiFi.getMode() == WIFI_AP) {
    // AP mode active: keep WiFi icon
    Serial.println("üì∂ AP mode active: bitmap stays on OLED");
  } else {
    // STA mode: connected to WiFi, clear WiFi icon
    display.clearDisplay();
    Serial.print("Connesso. IP: ");
    Serial.println(WiFi.localIP());
  }

  // --- Load stocks from FS ---
  loadListFromFS();

  // --- Web server ---
  server.on("/", handleRoot);
  server.on("/add", handleAdd);
  server.on("/remove", handleRemove);
  server.on("/clear", handleClear);
  server.begin();

  // --- Pins ---
  pinMode(buttonPin, INPUT);  
  pinMode(wifiResetButtonPin, INPUT);
  pinMode(ledGreenPin, OUTPUT);
  pinMode(ledRedPin, OUTPUT);
  digitalWrite(ledGreenPin, LOW);
  digitalWrite(ledRedPin, LOW);

  // --- Initialize time ---
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  while(!getLocalTime(&timeinfo)){
    Serial.println("Waiting for NTP time...");
    delay(1000);
  }

  Serial.println("Time synchronized!");
  if (getLocalTime(&timeinfo)) {
    Serial.printf("Local time: %02d:%02d:%02d\n", 
                  timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  }

  Serial.println("üü¢ Avviato in modalit√† DISPLAY");
  newStock = true; //when turned on downloads new data
}

// === Loop ===
unsigned long lastRequest = 0;

void loop() {
  // Handle WiFi reset button (hold >5s to clear credentials)
  static bool wifiResetPressed = false;
  static unsigned long wifiResetStart = 0;

  if (digitalRead(wifiResetButtonPin) == HIGH) {  // button pressed
    if (!wifiResetPressed) {
      wifiResetPressed = true;
      wifiResetStart = millis();
    } else if (millis() - wifiResetStart > 5000) {  // held > 5 sec
      Serial.println("üîß WiFi reset requested via button");
      digitalWrite(ledGreenPin, LOW);
      digitalWrite(ledRedPin, LOW);
      delay(500);
      WiFiManager wifiManager;
      wifiManager.resetSettings(); // clear saved credentials
      delay(500);
      ESP.restart();
    }
  } else {
    wifiResetPressed = false;  // reset if released early
  }

  // If in AP mode ‚Üí nothing else to do (just serve portal & show bitmap)
  if (WiFi.getMode() == WIFI_AP) {
    server.handleClient();
    return;
  }

  // If in STA mode ‚Üí normal stock display logic
  checkButton();

  if (serverMode) {
    server.handleClient();
    blinkLedsInServerMode();  
    showServerMode();
  } else {
    display.clearDisplay();

    if (!head) {
      showWallStreet();
      Serial.println("‚ö†Ô∏è No stocks to display. Use SERVER mode to add.");
      delay(3000);
      return;
    }

    if ((!isFetching && millis() - lastRequest > 600000) || (newStock)) {
      currentNode = head;
      isFetching = true;
      lastQuoteRequestTime = millis() - quoteDelay;
      lastRequest = millis();
    }

    if (isFetching) {
      showWallStreet();
      handleNonBlockingFetch();
      if (newStock) newStock = false;
    } else {
      updateDisplay();  // show current stock every 1 min
    }
  }
}
